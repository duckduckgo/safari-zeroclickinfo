{"version":3,"sources":["../../src/abp-filter-parser.js"],"names":["parseDomains","parseOptions","parseHTMLFilter","parseFilter","parse","matchesFilter","matches","getFingerprint","BloomFilterJS","fs","require","elementTypes","SCRIPT","IMAGE","STYLESHEET","OBJECT","XMLHTTPREQUEST","OBJECTSUBREQUEST","SUBDOCUMENT","DOCUMENT","OTHER","maxCached","maxUrlChars","fingerprintSize","fingerprintRegexs","elementTypeMaskMap","Map","separatorCharacters","input","separator","options","domains","skipDomains","split","concat","filter","domain","map","substring","Array","prototype","includes","searchElement","O","Object","len","parseInt","length","n","arguments","k","currentElement","output","binaryOptions","Set","forEach","option","trim","startsWith","domainString","optionWithoutPrefix","has","skipElementTypeMask","get","elementTypeMask","add","findFirstSeparatorChar","startPos","i","indexOf","index","parsedFilterData","domainsStr","isException","htmlRuleSelector","bloomFilter","exceptionBloomFilter","rawFilter","beginIndex","isComment","isRegex","match","data","slice","hostAnchored","indexOfSep","host","leftAnchored","rightAnchored","parserData","BloomFilter","filters","noFingerprintFilters","exceptionFilters","htmlRuleFilters","endPos","newline","fingerprint","push","getDomainIndex","indexOfFilter","startingPos","filterParts","prefixedSeparatorChar","f","getUrlHost","domainIndexStart","domainIndexEnd","filterDataContainsOption","isThirdPartyHost","baseContextHost","testHost","endsWith","c","undefined","matchOptions","contextParams","shouldBlockDomains","shouldSkipDomains","leftOverBlocking","shouldBlockDomain","every","shouldSkipDomain","leftOverSkipping","inputHost","inputHostIsThirdParty","cachedInputData","regex","RegExp","test","currentHost","parts","part","newIndex","discoverMatchingPrefix","array","str","prefixLen","sub","exists","badFingerprint","src","hasMatchingFilters","filterList","foundFilter","find","parsedFilterData2","matchedFilters","bloomNegativeCount","bloomPositiveCount","notMatchCount","badFingerprints","bloomFalsePositiveCount","hasMatchingNoFingerprintFilters","cleanedInput","replace","substringExists","misses","missList","delete","splice","exceptionBloomFilterMiss","fingerprintRegex","result","exec","lastIndex","badSubstring"],"mappings":"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","file":"abp-filter-parser.js","sourcesContent":["import * as BloomFilterJS from 'bloom-filter-js';\nimport {badFingerprints, badSubstrings} from './badFingerprints.js';\n\nlet fs = require('fs');\n\n/**\n * bitwise mask of different request types\n */\nexport const elementTypes = {\n  SCRIPT: 0o1,\n  IMAGE: 0o2,\n  STYLESHEET: 0o4,\n  OBJECT: 0o10,\n  XMLHTTPREQUEST: 0o20,\n  OBJECTSUBREQUEST: 0o40,\n  SUBDOCUMENT: 0o100,\n  DOCUMENT: 0o200,\n  OTHER: 0o400,\n};\n\n// Maximum number of cached entries to keep for subsequent lookups\nconst maxCached = 100;\n\n// Maximum number of URL chars to check in match clauses\nconst maxUrlChars = 100;\n\n// Exact size for fingerprints, if you change also change fingerprintRegexs\nconst fingerprintSize = 8;\n\n// Regexes used to create fingerprints\n// There's more than one because sometimes a fingerprint is determined to be a bad\n// one and would lead to a lot of collisions in the bloom filter). In those cases\n// we use the 2nd fingerprint.\nlet fingerprintRegexs = [\n  /.*([./&_\\-=a-zA-Z0-9]{8})\\$?.*/,\n  /([./&_\\-=a-zA-Z0-9]{8})\\$?.*/,\n];\n\n/**\n * Maps element types to type mask.\n */\nexport const elementTypeMaskMap = new Map([\n  ['script', elementTypes.SCRIPT],\n  ['image', elementTypes.IMAGE],\n  ['stylesheet', elementTypes.STYLESHEET],\n  ['object', elementTypes.OBJECT],\n  ['xmlhttprequest', elementTypes.XMLHTTPREQUEST],\n  ['object-subrequest', elementTypes.OBJECTSUBREQUEST],\n  ['subdocument', elementTypes.SUBDOCUMENT],\n  ['document', elementTypes.DOCUMENT],\n  ['other', elementTypes.OTHER]\n]);\n\nconst separatorCharacters = ':?/=^';\n\n/**\n * Parses the domain string using the passed in separator and\n * fills in options.\n */\nexport function parseDomains(input, separator, options) {\n  options.domains = options.domains || [];\n  options.skipDomains = options.skipDomains || [];\n  let domains = input.split(separator);\n  options.domains = options.domains.concat(domains.filter((domain) => domain[0] !== '~'));\n  options.skipDomains = options.skipDomains.concat(domains\n    .filter((domain) => domain[0] === '~')\n    .map((domain) => domain.substring(1)));\n}\n\nif (!Array.prototype.includes) {\n  Array.prototype.includes = function(searchElement /*, fromIndex*/ ) {\n    'use strict';\n    var O = Object(this);\n    var len = parseInt(O.length, 10) || 0;\n    if (len === 0) {\n      return false;\n    }\n    var n = parseInt(arguments[1], 10) || 0;\n    var k;\n    if (n >= 0) {\n      k = n;\n    } else {\n      k = len + n;\n      if (k < 0) {k = 0;}\n    }\n    var currentElement;\n    while (k < len) {\n      currentElement = O[k];\n      if (searchElement === currentElement ||\n         (searchElement !== searchElement && currentElement !== currentElement)) { // NaN !== NaN\n        return true;\n      }\n      k++;\n    }\n    return false;\n  };\n}\n\n\n/**\n * Parses options from the passed in input string\n */\nexport function parseOptions(input) {\n  let output = {\n    binaryOptions: new Set(),\n  };\n  input.split(',').forEach((option) => {\n    option = option.trim();\n    if (option.startsWith('domain=')) {\n      let domainString = option.split('=')[1].trim();\n      parseDomains(domainString, '|', output);\n    } else {\n      let optionWithoutPrefix = option[0] === '~' ? option.substring(1) : option;\n      if (elementTypeMaskMap.has(optionWithoutPrefix)) {\n        if (option[0] === '~') {\n          output.skipElementTypeMask |= elementTypeMaskMap.get(optionWithoutPrefix);\n        } else {\n          output.elementTypeMask |= elementTypeMaskMap.get(optionWithoutPrefix);\n        }\n      }\n      output.binaryOptions.add(option);\n    }\n  });\n  return output;\n}\n\n/**\n * Finds the first separator character in the input string\n */\nfunction findFirstSeparatorChar(input, startPos) {\n  for (let i = startPos; i < input.length; i++) {\n    if (separatorCharacters.indexOf(input[i]) !== -1) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n/**\n * Parses an HTML filter and modifies the passed in parsedFilterData\n * as necessary.\n *\n * @param input: The entire input string to consider\n * @param index: Index of the first hash\n * @param parsedFilterData: The parsedFilterData object to fill\n */\nexport function parseHTMLFilter(input, index, parsedFilterData) {\n  let domainsStr = input.substring(0, index);\n  parsedFilterData.options = {};\n  if (domainsStr.length > 0) {\n    parseDomains(domainsStr, ',', parsedFilterData.options);\n  }\n\n  // The XOR parsedFilterData.elementHidingException is in case the rule already\n  // was specified as exception handling with a prefixed @@\n  parsedFilterData.isException = !!(input[index + 1] === '@' ^\n    parsedFilterData.isException);\n  if (input[index + 1] === '@') {\n    // Skip passed the first # since @# is 2 chars same as ##\n    index++;\n  }\n  parsedFilterData.htmlRuleSelector = input.substring(index + 2);\n}\n\nexport function parseFilter(input, parsedFilterData, bloomFilter, exceptionBloomFilter) {\n  input = input.trim();\n  parsedFilterData.rawFilter = input;\n\n  // Check for comment or nothing\n  if (input.length === 0) {\n    return false;\n  }\n\n  // Check for comments\n  let beginIndex = 0;\n  if (input[beginIndex] === '[' || input[beginIndex] === '!') {\n    parsedFilterData.isComment = true;\n    return false;\n  }\n\n  // Check for exception instead of filter\n  parsedFilterData.isException = input[beginIndex] === '@' &&\n    input[beginIndex + 1] === '@';\n  if (parsedFilterData.isException) {\n    beginIndex = 2;\n  }\n\n  // Check for element hiding rules\n  let index = input.indexOf('#', beginIndex);\n  if (index !== -1) {\n    if (input[index + 1] === '#' || input[index + 1] === '@') {\n      parseHTMLFilter(input.substring(beginIndex), index - beginIndex, parsedFilterData);\n      // HTML rules cannot be combined with other parsing,\n      // other than @@ exception marking.\n      return true;\n    }\n  }\n\n  // Check for options, regex can have options too so check this before regex\n  index = input.indexOf('$', beginIndex);\n  if (index !== -1) {\n    parsedFilterData.options = parseOptions(input.substring(index + 1));\n    // Get rid of the trailing options for the rest of the parsing\n    input = input.substring(0, index);\n  } else {\n    parsedFilterData.options = {};\n  }\n\n  // Check for a regex\n  parsedFilterData.isRegex = input[beginIndex] === '/' &&\n    input[input.length - 1] === '/' && beginIndex !== input.length - 1;\n  if (parsedFilterData.isRegex) {\n      \n      // check for escaped forward slashes\n      if (input.match(/\\/$/)) {\n          parsedFilterData.data = input.slice(beginIndex + 1);\n      } else {\n          parsedFilterData.data = input.slice(beginIndex + 1, -1);\n      }\n      \n      return true;\n  }\n\n  // Check if there's some kind of anchoring\n  if (input[beginIndex] === '|') {\n    // Check for an anchored domain name\n    if (input[beginIndex + 1] === '|') {\n      parsedFilterData.hostAnchored = true;\n      let indexOfSep = findFirstSeparatorChar(input, beginIndex + 1);\n      if (indexOfSep === -1) {\n        indexOfSep = input.length;\n      }\n      beginIndex += 2;\n      parsedFilterData.host = input.substring(beginIndex, indexOfSep);\n    } else {\n      parsedFilterData.leftAnchored = true;\n      beginIndex++;\n    }\n  }\n  if (input[input.length - 1] === '|') {\n    parsedFilterData.rightAnchored = true;\n    input = input.substring(0, input.length - 1);\n  }\n\n  parsedFilterData.data = input.substring(beginIndex) || '*';\n  // Use the host bloom filter if the filter is a host anchored filter rule with no other data\n  if (exceptionBloomFilter && parsedFilterData.isException) {\n    exceptionBloomFilter.add(getFingerprint(parsedFilterData.data));\n  } else if (bloomFilter) {\n    // To check for duplicates\n    //if (bloomFilter.exists(getFingerprint(parsedFilterData.data))) {\n      // console.log('duplicate found for data: ' + getFingerprint(parsedFilterData.data));\n    //}\n    // console.log('parse:', parsedFilterData.data, 'fingerprint:', getFingerprint(parsedFilterData.data));\n    bloomFilter.add(getFingerprint(parsedFilterData.data));\n  }\n\n  return true;\n}\n\n/**\n * Parses the set of filter rules and fills in parserData\n * @param input filter rules\n * @param parserData out parameter which will be filled\n *   with the filters, exceptionFilters and htmlRuleFilters.\n */\nexport function parse(input, parserData) {\n  parserData.bloomFilter = parserData.bloomFilter || new BloomFilterJS.BloomFilter();\n  parserData.exceptionBloomFilter = parserData.exceptionBloomFilter || new BloomFilterJS.BloomFilter();\n  parserData.filters = parserData.filters || [];\n  parserData.noFingerprintFilters = parserData.noFingerprintFilters || [];\n  parserData.exceptionFilters = parserData.exceptionFilters || [];\n  parserData.htmlRuleFilters = parserData.htmlRuleFilters || [];\n  let startPos = 0;\n  let endPos = input.length;\n  let newline = '\\n';\n  while (startPos <= input.length) {\n    endPos = input.indexOf(newline, startPos);\n    if (endPos === -1) {\n      newline = '\\r';\n      endPos = input.indexOf(newline, startPos);\n    }\n    if (endPos === -1) {\n      endPos = input.length;\n    }\n    let filter = input.substring(startPos, endPos);\n    let parsedFilterData = {};\n    if (parseFilter(filter, parsedFilterData, parserData.bloomFilter, parserData.exceptionBloomFilter)) {\n      let fingerprint = getFingerprint(parsedFilterData.data);\n      if (parsedFilterData.htmlRuleSelector) {\n        parserData.htmlRuleFilters.push(parsedFilterData);\n      } else if (parsedFilterData.isException) {\n        parserData.exceptionFilters.push(parsedFilterData);\n      } else if (fingerprint.length > 0) {\n        parserData.filters.push(parsedFilterData);\n      } else {\n        parserData.noFingerprintFilters.push(parsedFilterData);\n      }\n    }\n    startPos = endPos + 1;\n  }\n}\n\n/**\n * Obtains the domain index of the input filter line\n */\nfunction getDomainIndex(input) {\n  let index = input.indexOf(':');\n  ++index;\n  while (input[index] === '/') {\n    index++;\n  }\n  return index;\n}\n\n/**\n * Similar to str1.indexOf(filter, startingPos) but with\n * extra consideration to some ABP filter rules like ^.\n */\nfunction indexOfFilter(input, filter, startingPos) {\n  if (filter.length > input.length) {\n    return -1;\n  }\n\n  let filterParts = filter.split('^');\n  let index = startingPos;\n  let beginIndex = -1;\n  let prefixedSeparatorChar = false;\n\n  for (let f = 0; f < filterParts.length; f++) {\n    if (filterParts[f] === '') {\n      prefixedSeparatorChar = true;\n      continue;\n    }\n\n    index = input.indexOf(filterParts[f], index);\n    if (index === -1) {\n      return -1;\n    }\n    if (beginIndex === -1) {\n      beginIndex = index;\n    }\n\n    if (prefixedSeparatorChar) {\n      if (separatorCharacters.indexOf(input[index - 1]) === -1) {\n        return -1;\n      }\n    }\n    // If we are in an in between filterPart\n    if (f + 1 < filterParts.length &&\n        // and we have some chars left in the input past the last filter match\n        input.length > index + filterParts[f].length) {\n      if (separatorCharacters.indexOf(input[index + filterParts[f].length]) === -1) {\n        return -1;\n      }\n\n    }\n\n    prefixedSeparatorChar = false;\n  }\n  return beginIndex;\n}\n\nfunction getUrlHost(input) {\n  let domainIndexStart = getDomainIndex(input);\n  let domainIndexEnd = findFirstSeparatorChar(input, domainIndexStart);\n  if (domainIndexEnd === -1) {\n    domainIndexEnd = input.length;\n  }\n  return input.substring(domainIndexStart, domainIndexEnd);\n}\n\nfunction filterDataContainsOption(parsedFilterData, option) {\n  return parsedFilterData.options &&\n    parsedFilterData.options.binaryOptions &&\n    parsedFilterData.options.binaryOptions.has(option);\n}\n\nfunction isThirdPartyHost(baseContextHost, testHost) {\n  if (!testHost.endsWith(baseContextHost)) {\n    return true;\n  }\n\n  let c = testHost[testHost.length - baseContextHost.length - 1];\n  return c !== '.' && c !== undefined;\n}\n\n// Determines if there's a match based on the options, this doesn't\n// mean that the filter rule shoudl be accepted, just that the filter rule\n// should be considered given the current context.\n// By specifying context params, you can filter out the number of rules which are\n// considered.\nfunction matchOptions(parsedFilterData, input, contextParams = {}) {\n  if (contextParams.elementTypeMask !== undefined && parsedFilterData.options) {\n    if (parsedFilterData.options.elementTypeMask !== undefined &&\n        !(parsedFilterData.options.elementTypeMask & contextParams.elementTypeMask)) {\n      return false;\n    } if (parsedFilterData.options.skipElementTypeMask !== undefined &&\n          parsedFilterData.options.skipElementTypeMask & contextParams.elementTypeMask) {\n      return false;\n    }\n  }\n\n  // Domain option check\n  if (contextParams.domain !== undefined && parsedFilterData.options) {\n    if (parsedFilterData.options.domains || parsedFilterData.options.skipDomains) {\n      // Get the domains that should be considered\n      let shouldBlockDomains = parsedFilterData.options.domains.filter((domain) =>\n        !isThirdPartyHost(domain, contextParams.domain));\n\n      let shouldSkipDomains = parsedFilterData.options.skipDomains.filter((domain) =>\n        !isThirdPartyHost(domain, contextParams.domain));\n      // Handle cases like: example.com|~foo.example.com should llow for foo.example.com\n      // But ~example.com|foo.example.com should block for foo.example.com\n      let leftOverBlocking = shouldBlockDomains.filter((shouldBlockDomain) =>\n        shouldSkipDomains.every((shouldSkipDomain) =>\n          isThirdPartyHost(shouldBlockDomain, shouldSkipDomain)));\n      let leftOverSkipping = shouldSkipDomains.filter((shouldSkipDomain) =>\n        shouldBlockDomains.every((shouldBlockDomain) =>\n          isThirdPartyHost(shouldSkipDomain, shouldBlockDomain)));\n\n      // If we have none left over, then we shouldn't consider this a match\n      if (shouldBlockDomains.length === 0 && parsedFilterData.options.domains.length !== 0 ||\n          shouldBlockDomains.length > 0 && leftOverBlocking.length === 0 ||\n          shouldSkipDomains.length > 0 && leftOverSkipping.length > 0) {\n        return false;\n      }\n    }\n  }\n\n  // If we're in the context of third-party site, then consider third-party option checks\n  if (contextParams['third-party'] !== undefined) {\n    // Is the current rule check for third party only?\n    if (filterDataContainsOption(parsedFilterData, 'third-party')) {\n      let inputHost = getUrlHost(input);\n      let inputHostIsThirdParty = isThirdPartyHost(parsedFilterData.host, inputHost);\n      if (inputHostIsThirdParty || !contextParams['third-party']) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Given an individual parsed filter data determines if the input url should block.\n */\nexport function matchesFilter(parsedFilterData, input, contextParams = {}, cachedInputData = {}) {\n  if (!matchOptions(parsedFilterData, input, contextParams)) {\n    return false;\n  }\n\n  // Check for a regex match\n  if (parsedFilterData.isRegex) {\n    if (!parsedFilterData.regex) {\n      parsedFilterData.regex = new RegExp(parsedFilterData.data);\n    }\n    return parsedFilterData.regex.test(input);\n  }\n\n  // Check for both left and right anchored\n  if (parsedFilterData.leftAnchored && parsedFilterData.rightAnchored) {\n    return parsedFilterData.data === input;\n  }\n\n  // Check for right anchored\n  if (parsedFilterData.rightAnchored) {\n    return input.slice(-parsedFilterData.data.length) === parsedFilterData.data;\n  }\n\n  // Check for left anchored\n  if (parsedFilterData.leftAnchored) {\n    return input.substring(0, parsedFilterData.data.length) === parsedFilterData.data;\n  }\n\n  // Check for domain name anchored\n  if (parsedFilterData.hostAnchored) {\n    if (!cachedInputData.currentHost) {\n      cachedInputData.currentHost = getUrlHost(input);\n    }\n\n    return !isThirdPartyHost(parsedFilterData.host, cachedInputData.currentHost) &&\n      indexOfFilter(input, parsedFilterData.data) !== -1;\n  }\n\n  // Wildcard match comparison\n  let parts = parsedFilterData.data.split('*');\n  let index = 0;\n  for (let part of parts) {\n    let newIndex = indexOfFilter(input, part, index);\n    if (newIndex === -1) {\n      return false;\n    }\n    index = newIndex + part.length;\n  }\n\n  return true;\n}\n\nfunction discoverMatchingPrefix(array, bloomFilter, str, prefixLen = fingerprintSize) {\n  for (var i = 0; i < str.length - prefixLen + 1; i++) {\n    let sub = str.substring(i, i + prefixLen);\n    if (bloomFilter.exists(sub)) {\n      array.push({ badFingerprint: sub, src: str});\n      // console.log('bad-fingerprint:', sub, 'for url:', str);\n    } else {\n      // console.log('good-fingerprint:', sub, 'for url:', str);\n    }\n  }\n}\n\nfunction hasMatchingFilters(filterList, parsedFilterData, input, contextParams, cachedInputData) {\n  const foundFilter = filterList.find(parsedFilterData2 =>\n    matchesFilter(parsedFilterData2, input, contextParams, cachedInputData));\n  if (foundFilter && cachedInputData.matchedFilters && foundFilter.rawFilter) {\n\n    // increment the count of matches\n    // we store an extra object and a count so that in the future\n    // other bits of information can be recorded during match time\n    if (cachedInputData.matchedFilters[foundFilter.rawFilter]) {\n      cachedInputData.matchedFilters[foundFilter.rawFilter].matches += 1;\n    } else {\n      cachedInputData.matchedFilters[foundFilter.rawFilter]  = { matches: 1 };\n    }\n\n    // can't write to local files like this\n    //fs.writeFileSync('easylist-matches.json', JSON.stringify(cachedInputData.matchedFilters), 'utf-8');\n  }\n  return !!foundFilter;\n}\n\n/**\n * Using the parserData rules will try to see if the input URL should be blocked or not\n * @param parserData The filter data obtained from a call to parse\n * @param input The input URL\n * @return true if the URL should be blocked\n */\nexport function matches(parserData, input, contextParams = {}, cachedInputData = { }) {\n  cachedInputData.bloomNegativeCount = cachedInputData.bloomNegativeCount || 0;\n  cachedInputData.bloomPositiveCount = cachedInputData.bloomPositiveCount || 0;\n  cachedInputData.notMatchCount = cachedInputData.notMatchCount || 0;\n  cachedInputData.badFingerprints = cachedInputData.badFingerprints || [];\n  cachedInputData.matchedFilters = cachedInputData.matchedFilters || {};\n\n  cachedInputData.bloomFalsePositiveCount = cachedInputData.bloomFalsePositiveCount || 0;\n  let hasMatchingNoFingerprintFilters;\n  let cleanedInput = input.replace(/^https?:\\/\\//, '');\n  if (cleanedInput.length > maxUrlChars) {\n    cleanedInput = cleanedInput.substring(0, maxUrlChars);\n  }\n  if (parserData.bloomFilter) {\n    if (!parserData.bloomFilter.substringExists(cleanedInput, fingerprintSize)) {\n      cachedInputData.bloomNegativeCount++;\n      cachedInputData.notMatchCount++;\n      // console.log('early return because of bloom filter check!');\n      hasMatchingNoFingerprintFilters =\n        hasMatchingFilters(parserData.noFingerprintFilters, parserData, input, contextParams, cachedInputData);\n\n      if (!hasMatchingNoFingerprintFilters) {\n        return false;\n      }\n    }\n    // console.log('looked for url in bloom filter and it said yes:', cleaned);\n  }\n  cachedInputData.bloomPositiveCount++;\n\n  // console.log('not early return: ', input);\n  delete cachedInputData.currentHost;\n  cachedInputData.misses = cachedInputData.misses || new Set();\n  cachedInputData.missList = cachedInputData.missList || [];\n  if (cachedInputData.missList.length > maxCached) {\n    cachedInputData.misses.delete(cachedInputData.missList[0]);\n    cachedInputData.missList = cachedInputData.missList.splice(1);\n  }\n  if (cachedInputData.misses.has(input)) {\n    cachedInputData.notMatchCount++;\n    // console.log('positive match for input: ', input);\n    return false;\n  }\n\n  if (hasMatchingFilters(parserData.filters, parserData, input, contextParams, cachedInputData) ||\n      hasMatchingNoFingerprintFilters === true || hasMatchingNoFingerprintFilters === undefined &&\n      hasMatchingFilters(parserData.noFingerprintFilters, parserData, input, contextParams, cachedInputData)) {\n    // Check for exceptions only when there's a match because matches are\n    // rare compared to the volume of checks\n    let exceptionBloomFilterMiss = parserData.exceptionBloomFilter && !parserData.exceptionBloomFilter.substringExists(cleanedInput, fingerprintSize);\n    if (!exceptionBloomFilterMiss || hasMatchingFilters(parserData.exceptionFilters, parserData, input, contextParams, cachedInputData)) {\n      cachedInputData.notMatchCount++;\n      return false;\n    }\n    return true;\n  }\n\n  // The bloom filter had a false positive, se we checked for nothing! :'(\n  // This is probably (but not always) an indication that the fingerprint selection should be tweaked!\n  cachedInputData.missList.push(input);\n  cachedInputData.misses.add(input);\n  cachedInputData.notMatchCount++;\n  cachedInputData.bloomFalsePositiveCount++;\n  discoverMatchingPrefix(cachedInputData.badFingerprints, parserData.bloomFilter, cleanedInput);\n  // console.log('positive match for input: ', input);\n  return false;\n}\n\n/**\n * Obtains a fingerprint for the specified filter\n */\nexport function getFingerprint(str) {\n  for (var i = 0; i < fingerprintRegexs.length; i++) {\n    let fingerprintRegex = fingerprintRegexs[i];\n    let result = fingerprintRegex.exec(str);\n    fingerprintRegex.lastIndex = 0;\n\n    if (result &&\n        !badFingerprints.includes(result[1]) &&\n        !badSubstrings.find(badSubstring => result[1].includes(badSubstring))) {\n      return result[1];\n    }\n    if (result) {\n      // console.log('checking again for str:', str, 'result:', result[1]);\n    } else {\n      // console.log('checking again for str, no result');\n    }\n  }\n  // This is pretty ugly but getting fingerprints is assumed to be used only when preprocessing and\n  // in a live environment.\n  if (str.length > 8) {\n    // Remove first and last char\n    return getFingerprint(str.slice(1, -1));\n  }\n  // console.warn('Warning: Could not determine a good fingerprint for:', str);\n  return '';\n}\n"]}